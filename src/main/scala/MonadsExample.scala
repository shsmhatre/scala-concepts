import scala.concurrent.Future
import scala.concurrent.ExecutionContext
import scala.util.Success
/**
 * Monads are structure that represent sequential computations
 *  In Monads, the output of a calculation at any step is the input to other calculations
 *  For comprehension -->
 *    Scala offers a lightweight notation for expressing sequence comprehensions.
 *    Comprehensions have the form for (enumerators) yield e,
 *    where enumerators refers to a semicolon-separated list of enumerators.
 *    An enumerator is either a generator which introduces new variables, or it is a filter.
 *    A comprehension evaluates the body e for each binding generated by the enumerators
 *    and returns a sequence of these values
 *
 * Monads and For comprehension are used for Extract-Transform-Wrap
 *
 */
object MonadsExample extends App{
    var numbers = List(1, 2, 3)
    var chars = List('a', 'b', 'c')
    //if you want make a tuple of from these 2 lists like (1, 'a') without monads
    var numChars : List[(Int, Char)] = List()
    for(a <- numbers) {
        for (c <- chars) {
            numChars = numChars :+ (a,c)
        }
    }
    println("Number chars:"+numChars)
    var numChars2:List[(Int, Char)] = for {
        number<-numbers
        char<-chars
    } yield (number, char)
    println("Number chars 2:"+numChars2)

    //Another example
    case class User(id: String)
    case class Product(id:String, price: Double)
    implicit val ec: scala.concurrent.ExecutionContext = scala.concurrent.ExecutionContext.global

    def getUser(name : String) : Future[User] = Future{
        User("suhas") //lets say this is an REST API call to getUserId from username
    }
    def getLastOrder(userId : String)  = Future {
      Product("mobile", 23000.0) //this is another REST API call to get last order for that userId
    }
    //Without Monads and For comprehension if we have to call these dependent APIs then, we have to do
    // like this
    getUser("Suhas").onComplete ({
        case Success(User(id)) =>
            val lastOrder = getLastOrder(id)
            lastOrder.onComplete({
                case Success(Product(name, price)) =>
                    val vatIncludedLastOrderPrice = price + (price * 19/100)
            })
    })


    //With Monads and for comprehension it will be like this
    val vatInlcudedLastOrderPrice : Future[Double] = for {
        user <- getUser("Suhas")
        product <- getLastOrder(user.id)
    } yield (product.price + (product.price * 19/100))

}
